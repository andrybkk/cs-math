#import "@preview/cetz:0.3.2"

#set page(
  paper: "a4", 
  margin: (x: 2cm, y: 2.5cm), 
  numbering: "1 / 1"
)

#set text(
  font: "New Computer Modern",
  size: 13pt,
  lang: "ru"
)

#set par(
  justify: true,
  leading: 0.65em
)

#show heading: set text(fill: blue.darken(20%))
#show heading: set text(weight: "bold")

#show heading.where(level: 1): it => [
  #set text(size: 24pt)
  #v(1em)
  #it
  #v(-20pt)
  #line(length: 100%, stroke: 1pt + blue.darken(20%))
]

#show heading.where(level: 2): set text(size: 18pt)

#let note(title, body) = rect(
  fill: blue.lighten(90%),
  stroke: blue.darken(20%) + 1pt,
  radius: 4pt,
  width: 100%,
  inset: 12pt
)[
  *#title* \
  #body
]

#let ax(id, body) = grid(
  columns: (30pt, 1fr),
  gutter: 10pt,
  v(0em) + [*#id*],
  body
)

#let axiom_block(title, content) = block(
  width: 100%,
  stroke: 0.5pt + gray,
  radius: 3pt,
  inset: 12pt,
  fill: rgb("#fafafa")
)[
  #set text(size: 11pt)
  #align(center)[#text(weight: "bold", size: 13pt)[#title]]
  #v(0.4em)
  #content
]

#let Arg = math.op("Arg")
#let arg = math.op("arg")
#let Re = math.op("Re")
#let Im = math.op("Im")
#let sgn = math.op("sgn")

= Линал

= Основные алгебраические структуры. Комплексные числа. Многочлены.

#note("Понятие поля, примеры", [
  *Поле* - множество F, на котором заданы две операции (сложение и умножение),
  для которых выполняются следующие аксиомы:
])

#axiom_block("Аксиомы поля", [
  *Аксиомы сложения*:
  #ax("1", [Коммутативность: $a + b = b + a$])
  #ax("2", [Ассоциативность: $(a+b)+c=a+(b+c)$])
  #ax("3", [Наличие нуля: $a+0=a$])
  #ax("4", [Наличие противоположного элемента: $exists (-a):a+(-a)=0$])
  *Аксиомы умножения*:
  #ax("5", [Коммутативность: $a*b = b*a$])
  #ax("6", [Ассоциативность: $(a*b)*c=a*(b*c)$])
  #ax("7", [Есть единица:  $a*1=a$])
  #ax("8", [Есть обратный элемент: $forall a != 0: exists a^(-1): a*a^(-1)=1$])
  #ax("9", [Дистрибутивность: $a*(b+c)=a*b+a*c$])
])

== Примеры полей:
#axiom_block("Примеры полей", [
  #ax("1", [$QQ$ - поле рациональных чисел])
  #ax("2", [$RR$ - поле вещественных чисел])
  #ax("3", [$CC$ - поле комплексных чисел (неупорядоченно)])
])
#v(1em)
== Примеры НЕполей
- $ZZ$ (Целые числа) — *не поле*, так как $(ZZ backslash {0}, *)$ не является группой (нет обратных элементов, кроме $1$ и $-1$).
- $NN$ (Натуральные числа) — *не группа и не множество*: даже по сложению (нет нейтрального элемента $0$ и противоположных чисел).
#v(2em)

#note("Абелева группа, аддитивная, мультипликативная группа поля.", [
  *Абелева группа* - множество $G$ с заданной на нем бинарной операцией $*$, для которого выполняются аксиомы:
])

#axiom_block("Аксиомы Абелевой группы", [
  #ax("1", [Коммутативность: $forall a, b in G: a*b=b*a$])
  #ax("2", [Ассоциативность: $forall a, b, c in G: (a*b)*c=a*(b*c)$])
  #ax("3", [Наличие нейтрального элемента: $exists e in G: a*e=e*a=a$])
  #ax("4", [Наличие обратного элемента: $forall a in G: exists a^(-1): a^(-1)*a=e$])
  #ax("5", [Замкнутость: $forall a, b in G => (a * b) in G$])
])

#v(1em)
#note("Группы в структуре поля", [
  Поле $F$ — это структура, объединяющая две Абелевы группы:
])

=== Примеры Абелевых групп:
- Вектора по сложению $(RR^(2), +)$
- Матрицы $m * n$ по сложению $(M_(m, n), +)$

#table(
  columns: (1fr, 1.2fr, 1.2fr),
  inset: 10pt,
  align: horizon,
  [*Свойство*], [*Аддитивная группа*], [*Мультипликативная группа*],
  [Множество $G$], [$F$ (все элементы)], [$F without {0}$ (без нуля)],
  [Операция $*$], [$+$ (сложение)], [$dot$ (умножение)],
  [Нейтральный $e$], [$0$ (нуль)], [$1$ (единица)],
  [Обратный $a^(-1)$], [$-a$ (противоположный)], [$a^(-1)$ (обратный)]
)
#v(6em)

= Построение поля комплексных чисел

== 1. Формальная конструкция

#note("Определение", [
  Множество комплексных чисел $CC$ — это множество упорядоченных пар вещественных чисел $(a, b)$, для которых введены операции:
  - *Сложение*: $(a, b) + (c, d) = (a+c, b+d)$
  - *Умножение*: $(a, b) dot (c, d) = (a c - b d, a d + b c)$
])

Для элементов вида $(a, 0)$ операции совпадают с операциями в $RR$, поэтому $RR subset CC$. 
Обозначим $(0, 1) = i$. Тогда $i^2 = (-1, 0) = -1$.

== 2. Алгебраическая форма
Любое число $z = (a, b)$ можно записать как:
$ z = a + b i $
Где:
- $a = Re(z)$ — вещественная (реальная) часть.
- $b = Im(z)$ — мнимая часть.

== 3. Комплексное сопряжение
#axiom_block("Определение и свойства сопряжения", [
  Число $macron(z) = a - b i$ называется *комплексно сопряженным* к числу $z = a + b i$.
  
  *Основные свойства:*
  1. $macron(macron(z)) = z$ (инволюция)
  2. $macron(z_1 + z_2) = macron(z_1) + macron(z_2)$
  3. $macron(z_1 dot z_2) = macron(z_1) dot macron(z_2)$
  4. $z dot macron(z) = a^2 + b^2$ (всегда вещественное неотрицательное число)
])

#pagebreak()
== Проверка аксиом поля $CC$

Все аксиомы поля для $CC$ выполняются в силу соответствующих аксиом для поля $RR$.

#axiom_block("Краткая проверка основных свойств", [
  - *Коммутативность $+ и dot$*: следует из коммутативности операций в $RR$.
  - *Нейтральные элементы*:
    - По сложению: $0_CC = (0, 0)$
    - По умножению: $1_CC = (1, 0)$
  - *Обратные элементы*:
    - По сложению: $-z = (-a, -b)$
    - По умножению (для $z != 0$): $z^(-1) = (a / (a^2+b^2), -b / (a^2+b^2))$
  - *Ассоциативность и дистрибутивность*: проверяются прямой подстановкой и раскрытием скобок.
])

= Геометрическая модель КЧ, интерпретация сложения и сопряжения в этой модели

#align(center)[
  #cetz.canvas(length: 1cm, {
    import cetz.draw: *
    
    line((-1, 0), (4, 0), mark: (end: "stealth"), name: "x-axis")
    line((0, -1), (0, 3), mark: (end: "stealth"), name: "y-axis")
    
    content((4.2, 0), $Re$, anchor: "west")
    content((0, 3.2), $Im$, anchor: "south")
    
    
    let z = (3.0, 2.0)
    line((z.at(0), 0), z, stroke: (dash: "dashed", paint: gray))
    line((0, z.at(1)), z, stroke: (dash: "dashed", paint: gray))
    
    content((z.at(0), -0.3), $a$)
    content((-0.3, z.at(1)), $b$)
    
    line((0, 0), z, stroke: (paint: blue, thickness: 2pt), mark: (end: "stealth"), name: "z-vec")
    
    content((z.at(0) + 0.2, z.at(1) + 0.2), $z = a + b i$, anchor: "west")
    
    content((1.0, 0.4), $phi$)
    content((1.5, 1.1), $r = |z|$, fill: white)
  })
]

#note("Геометрическая интерпретация", [
  *Комплексное число* $z = a + b i$ представляется как радиус-вектор на *комплексной плоскости*, где ось-абсцисс(x) - $Re(z)$, а ось ординат(y) - $Im(z)$
])

#pagebreak()
== Интерпретация операций

#axiom_block("Геометричский смысл операций", [
  - *Сложение*: сумма комплексных чисел $z_1 + z_2$ соответствует сумме соответствующих радиус-векторов (правило параллелограмма)
  - *Вычитание*: разность $z_1 - z_2$ - аналогично, векторная разность радиус-векторов, т.е. вектор из $z_2$ в $z_1$
  - *Сопряжение*: Переход от $z$ к $macron(z)$ - симметричное отражение точки отнасительно вещественной оси (x или $Re$)
  - *Модуль*: $|z|$ - евклидова длина вектора
  - *Аргумент*: $phi$ - ориентированный угол между положительным направлением $Re$ и вектором $z$
])

#figure(
  grid(
    columns: (1fr, 1fr, 1fr), // Три колонки одинаковой ширины
    gutter: 10pt,            // Отступ между графиками
    
    // ГРАФИК 1: СЛОЖЕНИЕ
    cetz.canvas(length: 0.6cm, {
      import cetz.draw: *
      line((-1, 0), (4, 0), mark: (end: "stealth")) // Re
      line((0, -1), (0, 4), mark: (end: "stealth")) // Im
      
      let z1 = (2.5, 1.0)
      let z2 = (1.0, 2.5)
      let sum = (z1.at(0) + z2.at(0), z1.at(1) + z2.at(1))
      
      line((0,0), z1, stroke: blue, mark: (end: "stealth"))
      line((0,0), z2, stroke: blue, mark: (end: "stealth"))
      line(z1, sum, stroke: (dash: "dashed", paint: gray))
      line(z2, sum, stroke: (dash: "dashed", paint: gray))
      line((0,0), sum, stroke: (paint: red, thickness: 1.5pt), mark: (end: "stealth"))
      
      content(z1, $z_1$, anchor: "west", padding: .1)
      content(z2, $z_2$, anchor: "south", padding: .1)
      content(sum, $z_1 + z_2$, anchor: "south-west")
      content((2, -1.7), [*Сложение*])
    }),

    // ГРАФИК 2: ВЫЧИТАНИЕ
    cetz.canvas(length: 0.6cm, {
      import cetz.draw: *
      line((-1, 0), (4, 0), mark: (end: "stealth"))
      line((0, -1), (0, 4), mark: (end: "stealth"))
      
      let z1 = (3.0, 2.5)
      let z2 = (1.0, 0.5)
      
      line((0,0), z1, stroke: blue, mark: (end: "stealth"))
      line((0,0), z2, stroke: blue, mark: (end: "stealth"))
      // Вектор разности между концами
      line(z2, z1, stroke: (paint: red, thickness: 1.5pt), mark: (end: "stealth"))
      
      content(z1, $z_1$, anchor: "south")
      content(z2, $z_2$, anchor: "north-west")
      content((3.2, 1.2), $z_1 - z_2$, fill: white)
      content((2, -2), [*Вычитание*])
    }),

    // ГРАФИК 3: СОПРЯЖЕНИЕ
    cetz.canvas(length: 0.6cm, {
      import cetz.draw: *
      line((-1, 0), (4, 0), mark: (end: "stealth"))
      line((0, -2.5), (0, 2.5), mark: (end: "stealth"))
      
      let z = (2.5, 1.5)
      let z_conj = (2.5, -1.5)
      
      line((0,0), z, stroke: blue, mark: (end: "stealth"))
      line((0,0), z_conj, stroke: (paint: red, thickness: 1.5pt), mark: (end: "stealth"))
      line(z, z_conj, stroke: (dash: "dotted", paint: gray))
      
      content(z, $z$, anchor: "south")
      content(z_conj, $macron(z)$, anchor: "north")
      content((2, -3.5), [*Сопряжение*])
    })
  ),
  caption: [Геометрический смысл операций над комплексными числами]
)

== Cвойста модуля
#axiom_block("Свойства модуля", [
  0. $|z| = sqrt(a^2 + b^2)$, e.g. $z = 3+4i => |z| = sqrt(9 + 16) = 5$
  1. $|z|>=0$; $|z| = 0 <=> z = 0$
  2. $|z_1 * z_2| = |z_1| * |z_2|$
  3. $|z_1 + z_2| <= |z_1| + |z_2|$ - из неравенства треугольника
  4. $|z|^2 = z * macron(z)$
])

#pagebreak()
= Аргумент КЧ
#note("Определение", [
  *Аргументом* ненулевого числа $z = a + b i$ называется угол $phi$ между положительной полуосью $Re$ и вектором $z$. 
  
  Связь с координатами:
  $ cases(cos phi = a / |z|, sin phi = b / |z|) $
])

== Главное значение аргумента $phi in (-pi, pi]$

#table(
  columns: (1fr, 1.5fr, 1.5fr),
  inset: 10pt,
  [*Четверть*], [*Условие*], [*Формула $arg(z)$*],
  [I], [$a > 0, b >= 0$], [$arctan(b/a)$],
  [II], [$a < 0, b >= 0$], [$arctan(b/a) + pi$],
  [III], [$a < 0, b < 0$], [$arctan(b/a) - pi$],
  [IV], [$a > 0, b < 0$], [$arctan(b/a)$],
  [Ось $Im$], [$a = 0, b != 0$], [$op("sgn")(b) dot pi/2$]
)

#v(1em)
#axiom_block("Свойства аргумента", [
  1. $Arg(z_1 * z_2) = Arg(z_1) + Arg(z_2)$
  2. $Arg(z_1 / z_2) = Arg(z_1) - Arg(z_2)$
  3. $Arg(z^n) = n dot Arg(z)$
])

#pagebreak()
= Тригонометрическая Форма
#note("Определение", [
  Любое комплексное число $z = a + b i$ ($z != 0$) может быть представлено в *тригонометрической форме*:
  $ z = r (cos phi + i sin phi) $
  Где $r = |z|$ — модуль, а $phi = arg(z)$ — аргумент числа.
])

== Операции в тригонометрической форме

Пусть $z_1 = r_1 (cos phi_1 + i sin phi_1)$ и $z_2 = r_2 (cos phi_2 + i sin phi_2)$.

#axiom_block("Алгебраические действия", [
  1. *Умножение*: модули перемножаются, аргументы складываются:
     $ z_1 dot z_2 = r_1 r_2 (cos(phi_1 + phi_2) + i sin(phi_1 + phi_2)) $
  2. *Деление*: модули делятся, аргументы вычитаются:
     $ z_1 / z_2 = r_1 / r_2 (cos(phi_1 - phi_2) + i sin(phi_1 - phi_2)) $
])

= Возведение в степень. #linebreak() Формула Муавра

#note("Формула Муавра", [
  Для любого целого $n$ справедливо:
  $ z^n = [r (cos phi + i sin phi)]^n = r^n (cos(n phi) + i sin(n phi)) $
])

*Геометрический смысл*: При возведении в степень $n$ вектор числа $z$ растягивается в $r^n$ раз и поворачивается на угол в $n$ раз больший исходного.

#note("Теорема", [
  Для любого комплексного числа $z = r(cos phi + i sin phi) != 0$ существует ровно $n$ различных значений корня $n$-ой степени.
])

Формула вытекает из обобщения формулы Муавра:
$ w_k = root(n, r) (cos ( (phi + 2 pi k) / n ) + i sin ( (phi + 2 pi k) / n )), space k = 0, 1, ..., n-1 $

#axiom_block("Геометрический смысл корней", [
  Все $n$ корней $w_k$ обладают следующими свойствами:
  1. Все они лежат на одной окружности радиуса $R = root(n, r)$.
  2. Аргументы соседних корней отличаются на $2 pi / n$.
  3. Точки, соответствующие корням, являются вершинами *правильного $n$-угольника*, вписанного в эту окружность.
])

== Экспоненциальная форма. Формула Эйлера

#note("Формула Эйлера", [
  Фундаментальная связь экспоненты и тригонометрии:
  $ e^(i phi) = cos phi + i sin phi $
])

Любое число $z = r (cos phi + i sin phi)$ можно записать в *экспоненциальной форме*:
$ z = r e^(i phi) $

#axiom_block("Свойства экспоненциальной формы", [
  В этой форме операции выполняются по обычным правилам работы со степенями:
  - *Умножение*: $r_1 e^(i phi_1) dot r_2 e^(i phi_2) = r_1 r_2 e^(i(phi_1 + phi_2))$
  - *Деление*: $(r_1 e^(i phi_1)) / (r_2 e^(i phi_2)) = r_1 / r_2 e^(i(phi_1 - phi_2))$
  - *Возведение в степень*: $(r e^(i phi))^n = r^n e^(i n phi)$
])

#pagebreak()

= Кольца
== 1. Коммутативные кольца
#note("Определение", [
  Множество $R$ с операциями $(+, dot)$ называется *коммутативным кольцом*, если:
  - $(R, +)$ — Абелева группа.
  - Операция $dot$ ассоциативна и коммутативна ($a dot b = b dot a$).
  - Выполняется дистрибутивность: $a(b+c) = a b + a c$.
])

*Примеры*: $ZZ$ (целые числа), $RR$ (поля также являются кольцами).

== 2. Кольцо многочленов $K[x]$
#note("Определение", [
  Пусть $K$ — поле. Множество всех выражений вида $P(x) = a_n x^n + ... + a_1 x + a_0$, где $a_i in K$, называется *кольцом многочленов* над полем $K$ и обозначается $K[x]$.
])

#axiom_block("Свойства кольца многочленов", [
  1. $K[x]$ является коммутативным ассоциативным кольцом с единицей (единица — это многочлен $P(x) = 1$).
  2. В $K[x]$ нет делителей нуля: если $P(x) dot Q(x) = 0$, то либо $P=0$, либо $Q=0$.
  3. $K[x]$ не является полем, так как для многочленов степени $deg(P) >= 1$ не существует обратного элемента в $K[x]$.
])

== Сравнение многочленов над $RR$ и $CC$
#axiom_block("Разложение на множители", [
  Согласно *Основной теореме алгебры*:
  
  1. В кольце $CC[x]$ любой многочлен степени $n$ разлагается на $n$ линейных множителей:
     $ P(x) = a_n (x - x_1)(x - x_2) dots (x - x_n) $
     
  2. В кольце $RR[x]$ любой многочлен разлагается на линейные множители и квадратичные множители с отрицательным дискриминантом:
     $ P(x) = a_n (x - a_1) dots (x^2 + p_1 x + q_1) dots $
])

#note("Важное свойство", [
  Если комплексное число $z$ является корнем многочлена с *вещественными* коэффициентами, то сопряженное число $macron(z)$ также является его корнем.
])

#note("Различие Кольца и Поля", [
  - *Поле*: $(F, +)$ — Абелева группа, $(F without {0}, dot)$ — Абелева группа.
  - *Кольцо*: $(R, +)$ — Абелева группа, а для $(R, dot)$ аксиома наличия обратного элемента $a^(-1)$ *не обязательна*.
])

*Пример*: В кольце многочленов $RR[x]$ обратный элемент существует только для констант (многочленов нулевой степени). Для $P(x) = x$ обратного многочлена не существует, так как $1/x cancel(in) RR[x]$.

== 3. Степень многочлена ($deg$)
Для любых $P, Q in K[x]$ выполняются свойства:
- $deg(P + Q) <= max(deg P, deg Q)$
- $deg(P dot Q) = deg P + deg Q$

#pagebreak()

== 1. Деление с остатком
#note("Теорема", [
  Для любых $P(x), Q(x) in K[x], Q != 0$, существуют единственные $S(x)$ и $R(x)$, такие что:
  $ P(x) = Q(x) dot S(x) + R(x), $
  где либо $R(x) = 0$, либо $deg R < deg Q$.
])

#axiom_block("Алгоритм", [
  Процесс деления (обычно "уголком") продолжается до тех пор, пока степень текущего остатка не станет меньше степени делителя $Q(x)$.
])

== 2. Теорема Безу
Это важнейший частный случай деления на двучлен $Q(x) = (x - a)$.

#note("Теорема Безу", [
  Остаток от деления многочлена $P(x)$ на $(x - a)$ равен значению этого многочлена в точке $a$:
  $ R = P(a) $
])

#axiom_block("Доказательство (в одну строчку)", [
  По теореме о делении с остатком: $P(x) = (x - a) dot S(x) + R$. \
  Подставим $x = a$: $P(a) = (a - a) dot S(a) + R => P(a) = R$. *Q.E.D.*
])

== 3. Следствия
1. Число $a$ является корнем многочлена $P(x) <=> P(x)$ делится на $(x - a)$ без остатка.
2. Многочлен степени $n$ имеет не более $n$ различных корней.

#v(3em)
#note("Определение", [
  Число $a$ называется *корнем кратности* $k$ многочлена $P(x)$, если:
  $ P(x) = (x - a)^k dot Q(x), space "где" Q(a) != 0 $
])

#axiom_block("Связь с производными", [
  Число $a$ является корнем кратности $k$ тогда и только тогда, когда:
  $ P(a) = P'(a) = P''(a) = ... = P^((k-1))(a) = 0, space "но" P^((k))(a) != 0 $
])

== 1. Разложение над полем $CC$
#note("Основная теорема алгебры", [
  Любой многочлен $P(x) in CC[x]$ степени $n >= 1$ имеет ровно $n$ корней (с учетом кратности) и разлагается на линейные множители:
  $ P(x) = a_n (x - z_1)^(k_1) (x - z_2)^(k_2) dots (x - z_m)^(k_m) $
  где $k_1 + k_2 + ... + k_m = n$.
])

== 2. Разложение над полем $RR$
#note("Теорема", [
  Любой многочлен $P(x) in RR[x]$ степени $n >= 1$ разлагается в произведение линейных и неразложимых квадратичных множителей:
  $ P(x) = a_n product (x - a_i)^(k_i) product (x^2 + p_j x + q_j)^(m_j) $
  где для всех квадратичных множителей $D = p_j^2 - 4q_j < 0$.
])

#axiom_block([Почему в $RR$ остаются квадраты?], [
  Комплексные корни вещественного многочлена всегда сопряжены. Произведение двух линейных множителей с сопряженными корнями дает вещественный квадратный трехчлен:
  $ (x - (alpha + i beta))(x - (alpha - i beta)) = x^2 - 2 alpha x + (alpha^2 + beta^2) $
])

#pagebreak()

= 1. Лемма о сопряженном корне
#note("Утверждение", [
  Пусть $P(x) in RR[x]$ (коэффициенты вещественны). Если комплексное число $z$ является корнем $P(x)$, то число $macron(z)$ также является его корнем.
])

#axiom_block("Доказательство", [
  1. Условие $P(z) = 0$ означает: $a_n z^n + a_(n-1) z^(n-1) + ... + a_0 = 0$.
  2. Применим операцию сопряжения к обеим частям:
     $ macron(sum_(k=0)^n a_k z^k) = macron(0) = 0 $
  3. По свойствам сопряжения (сумма сопряжений и произведение сопряжений):
     $ sum_(k=0)^n macron(a_k) (macron(z))^k = 0 $
  4. Так как коэффициенты $a_k$ вещественные, то $macron(a_k) = a_k$.
  5. Получаем: $sum a_k (macron(z))^k = 0$, то есть $P(macron(z)) = 0$. *Q.E.D.*
])

== 2. Теорема о разложении над $CC$
#note("Теорема", [
  Любой многочлен $P(x) in CC[x]$ степени $n >= 1$ разлагается на $n$ линейных множителей:
  $ P(x) = a_n (x - z_1) (x - z_2) dots (x - z_n) $
])

#axiom_block("Доказательство (Метод индукции)", [
  - *База*: Для $n=1$ многочлен $a_1 x + a_0 = a_1 (x - (-a_0/a_1))$ уже разложен.
  - *Предположение*: Пусть утверждение верно для многочленов степени $n-1$.
  - *Шаг*: Рассмотрим $P(x)$ степени $n$. 
    1. По *Основной теореме алгебры* у $P(x)$ есть хотя бы один корень $z_1$.
    2. По теореме Безу: $P(x) = (x - z_1) Q(x)$, где $deg Q = n-1$.
    3. К $Q(x)$ применимо предположение индукции.
    4. Итого: $P(x) = (x - z_1) [a_n (x - z_2) dots (x - z_n)]$. *Q.E.D.*
])

== 3. Теорема о разложении над $RR$
#note("Теорема", [
  Любой многочлен $P(x) in RR[x]$ степени $n >= 1$ разлагается на линейные множители и неразложимые в $RR$ квадратичные множители ($D < 0$):
  $ P(x) = a_n product(x - x_i) product(x^2 + p_j x + q_j) $
])

#axiom_block("Доказательство", [
  1. Рассмотрим разложение $P(x)$ над полем $CC$.
  2. Вещественные корни $x_i$ дают линейные множители $(x - x_i)$.
  3. Комплексные корни по Лемме ходят парами $(z, macron(z))$. Перемножим соответствующую пару скобок:
     $ (x - z)(x - macron(z)) = x^2 - (z + macron(z))x + z macron(z) $
  4. По свойствам сопряженных чисел:
     - $z + macron(z) = 2 Re(z) = -p in RR$
     - $z macron(z) = |z|^2 = q in RR$
  5. Получаем вещественный квадратный трехчлен $x^2 + p x + q$. Он неразложим в $RR$, так как его корни комплексные.
])

#pagebreak()
= Теорема Виета

#note("Теорема", [
  Пусть $x_1, x_2, ..., x_n$ — корни многочлена 
  $ P(x) = a_n x^n + a_(n-1) x^(n-1) + ... + a_1 x + a_0 $
  Тогда коэффициенты многочлена связаны с его корнями следующими соотношениями:
])

#axiom_block("Формулы Виета", [
  $ cases(
    x_1 + x_2 + ... + x_n = - a_(n-1) / a_n,
    x_1 x_2 + x_1 x_3 + ... + x_(n-1) x_n = a_(n-2) / a_n,
    x_1 x_2 x_3 + ... = - a_(n-3) / a_n,
    dots,
    x_1 x_2 dots x_n = (-1)^n dot a_0 / a_n
  ) $
])

== Частные случаи (самые ходовые на экзамене)

#grid(
  columns: (1fr, 1fr),
  gutter: 20pt,
  axiom_block("Для n = 2 (квадратный)", [
    $x^2 + p x + q = 0$
    $ cases(x_1 + x_2 = -p, x_1 x_2 = q) $
  ]),
  axiom_block("Для n = 3 (кубический)", [
    $x^3 + a x^2 + b x + c = 0$
    $ cases(
      x_1 + x_2 + x_3 = -a,
      x_1 x_2 + x_2 x_3 + x_3 x_1 = b,
      x_1 x_2 x_3 = -c
    ) $
  ])
)

== Доказательство (идея)
Доказательство основано на тождественном равенстве двух форм многочлена:
1. По определению: $P(x) = a_n (x^n + a_(n-1)/a_n x^(n-1) + ...)$
2. По теореме о разложении: $P(x) = a_n (x - x_1)(x - x_2) dots (x - x_n)$

При раскрытии скобок во втором выражении и приравнивании коэффициентов при одинаковых степенях $x$ получаются формулы Виета.
#pagebreak()
#axiom_block("Общая формула Виета", [
  Для приведенного многочлена ($a_n = 1$) коэффициент при $x^(n-k)$ равен:
  $ a_(n-k) = (-1)^k sum_(1 <= i_1 < i_2 < ... < i_k <= n) x_(i_1) x_(i_2) dots x_(i_k) $
])

#note("По-простому", [
  - $k=1$: Сумма корней (знак $-$)
  - $k=2$: Сумма всех возможных пар (знак $+$)
  - $k=3$: Сумма всех возможных троек (знак $-$)
  - ...
  - $k=n$: Произведение всех корней (знак $(-1)^n$)
])

#pagebreak()
= Линейные пространства

#note("Определение", [
  Множество $V$ называется *линейным (векторным) пространством* над полем $F$, если на нём заданы операции сложения векторов и умножения вектора на скаляр, удовлетворяющие 8 аксиомам:
])

#let ar = math.arrow 

#axiom_block("I. Аксиомы сложения (Абелева группа)", [
  #ax("1", [$ar(a) + ar(b) = ar(b) + ar(a)$ (коммутативность)])
  #ax("2", [$(ar(a) + ar(b)) + ar(c) = ar(a) + (ar(b) + ar(c))$ (ассоциативность)])
  #ax("3", [$exists ar(0) in V: ar(a) + ar(0) = ar(a)$ (нейтральный элемент)])
  #ax("4", [$forall ar(a) exists (-ar(a)): ar(a) + (-ar(a)) = ar(0)$ (обратный элемент)])
])

#axiom_block("II. Аксиомы умножения на скаляр", [
  #ax("5", [$1 dot ar(a) = ar(a)$ (унитарность)])
  #ax("6", [$alpha dot (beta dot ar(a)) = (alpha beta) dot ar(a)$ (ассоциативность)])
  #ax("7", [$(alpha + beta) dot ar(a) = alpha ar(a) + beta ar(a)$ (дистрибутивность по числу)])
  #ax("8", [$alpha dot (ar(a) + ar(b)) = alpha ar(a) + alpha ar(b)$ (дистрибутивность по вектору)])
])

== Примеры линейных пространств
1. *Арифметическое пространство* $RR^n$: векторы-столбцы из $n$ чисел.
2. *Пространство матриц* $M_(m times n)$: матрицы одинакового размера.
3. *Пространство многочленов* $RR[x]$ (степени не выше $n$).

    
== Арифметическое линейное пространство $RR^n$

#note("Определение", [
  Множество всех упорядоченных совокупностей из $n$ вещественных чисел $x = (x_1, x_2, ..., x_n)$ с операциями:
  - *Сложение*: $(x_1, ..., x_n) + (y_1, ..., y_n) = (x_1 + y_1, ..., x_n + y_n)$
  - *Умножение*: $lambda (x_1, ..., x_n) = (lambda x_1, ..., lambda x_n)$
])

#v(3em)
#axiom_block([Стандартный базис в $RR^n$], [
  Система векторов $e_1, e_2, ..., e_n$, где $e_i$ содержит 1 на $i$-м месте и 0 на остальных:
  $ e_i = (0, ..., 1, ..., 0) $
  Эта система является базисом в $RR^n$, следовательно $dim RR^n = n$.
])

= Умножение матриц, его свойства


#note("Определение", [
  Произведением матрицы $A$ размера $m times n$ на матрицу $B$ размера $n times k$ называется матрица $C = A dot B$ размера $m times k$, элементы которой вычисляются по формуле:
  $ c_(i j) = sum_(r=1)^n a_(i r) b_(r j) $
  Где $i = 1..m, j = 1..k$.
])

#axiom_block("Главное условие", [
  Операция $A dot B$ определена тогда и только тогда, когда число столбцов матрицы $A$ равно числу строк матрицы $B$.
])

== Основные свойства

#axiom_block("Алгебраические свойства", [
  1. *Некоммутативность*: $A B != B A$ (в общем случае).
  2. *Ассоциативность*: $(A B) C = A (B C)$.
  3. *Дистрибутивность*: $A(B + C) = A B + A C$.
  4. *Связь со скаляром*: $lambda (A B) = (lambda A) B = A (lambda B)$.
  5. *Единичный элемент*: $exists I : A I = I A = A$.
])

== Транспонирование и След (Trace)
#note("Важные формулы", [
  - Транспонирование произведения: $(A B)^T = B^T A^T$ (порядок меняется!).
  - След матрицы (сумма диагонали): $op("tr")(A B) = op("tr")(B A)$.
])

#pagebreak()
= След матрицы и его свойства

#note("Определение", [
  *Следом* квадратной матрицы $A$ порядка $n$ называется сумма её диагональных элементов:
  $ op("tr")(A) = sum_(i=1)^n a_(i i) = a_(1 1) + a_(2 2) + ... + a_(n n) $
])

== Основные свойства следа

#axiom_block("Свойства", [
  #ax("1", [Линейность: $op("tr")(alpha A + beta B) = alpha op("tr")(A) + beta op("tr")(B)$])
  #ax("2", [След транспонированной матрицы: $op("tr")(A^T) = op("tr")(A)$])
  #ax("3", [Цикличность: $op("tr")(A B) = op("tr")(B A)$])
  #ax("4", [След единичной матрицы: $op("tr")(I_n) = n$])
])

#note("Важное замечание про произведение", [
  Хотя в общем случае $A B != B A$ (матрицы не коммутируют), их *следы всегда равны*. Это свойство работает, даже если $A$ и $B$ прямоугольные, при условии, что произведения $A B$ и $B A$ квадратные.
])

== Обобщение для экзамена (Циклическое свойство)
След произведения нескольких матриц не меняется при их циклической перестановке:
$ op("tr")(A B C) = op("tr")(B C A) = op("tr")(C A B) $
*Внимание*: Свойство $op("tr")(A B C) = op("tr")(A C B)$ в общем случае *неверно*!
Работает с циклической перестановкой

#pagebreak()
= СЛАУ. Основные понятия

#note("Определение", [
  *Системой линейных алгебраических уравнений* называется совокупность уравнений вида:
  $ sum_(j=1)^n a_(i j) x_j = b_i, space i = 1, ..., m $
])

== Формы записи системы
1. *Координатная*: обычная запись со знаком системы.
2. *Векторная*: $x_1 arrow(a)_1 + x_2 arrow(a)_2 + ... + x_n arrow(a)_n = arrow(b)$, где $arrow(a)_j$ — столбцы матрицы.
3. *Матричная*: $bold(A x = b)$.

== Расширенная матрица
Для решения системы используют *расширенную матрицу* $bold(tilde(A))$, к которой справа приписан столбец свободных членов через черту:
$ bold(tilde(A)) = (A | b) = mat(
  a_(1 1), ..., a_(1 n), |, b_1;
  ..., ..., ..., |, ...;
  a_(m 1), ..., a_(m n), |, b_m
) $

== Классификация систем
#table(
  columns: (1fr, 1.2fr, 2fr),
  inset: 10pt,
  [*Тип*], [*Свойство*], [*Количество решений*],
  [Совместная], [Решения есть], [Одно (определенная) или бесконечно много (неопределенная)],
  [Несовместная], [Решений нет], [0],
  [Однородная], [$bold(b) = 0$], [Всегда совместна (как минимум $x=0$)]
)

#v(1em)

#pagebreak()
= Линейное подпространство

#note("Определение", [
  Непустое подмножество $L$ линейного пространства $V$ называется его *подпространством*, если оно само является линейным пространством относительно операций, заданных в $V$.
])

#axiom_block("Критерии подпространства", [
  Для того чтобы подмножество $L subset V$ было подпространством, необходимо и достаточно выполнения трех условий:
  1. $arrow(0) in L$ (содержит нулевой вектор).
  2. $forall arrow(u), arrow(v) in L => (arrow(u) + arrow(v)) in L$ (замкнутость по сложению).
  3. $forall arrow(u) in L, forall alpha in F => (alpha arrow(u)) in L$ (замкнутость по умножению).
])

== Примеры и антипримеры в $RR^3$
- *Подпространства*: любая плоскость или прямая, проходящая через $(0,0,0)$.
- *Не подпространства*:
  - Плоскость $z = 1$ (не содержит ноль).
  - Множество векторов с целыми координатами (умножишь на $0.5$ — вылетишь из множества).

== Тривиальные подпространства
В любом пространстве $V$ всегда есть два "крайних" подпространства:
1. Нулевое подпространство: ${arrow(0)}$.
2. Само пространство $V$.

#pagebreak()
= Билет: Линейная оболочка системы векторов

#note("Определение", [
  *Линейной оболочкой* системы векторов $S = {arrow(a)_1, arrow(a)_2, ..., arrow(a)_k}$ называется множество всех их линейных комбинаций. 
  Обозначение: $L(S)$ или $chevron.l arrow(a)_1, ..., arrow(a)_k chevron.r$.
])

$ L(S) = { sum_(i=1)^k alpha_i arrow(a)_i mid alpha_i in F } $

== Свойства линейной оболочки

#axiom_block("Теорема о подпространстве", [
  Линейная оболочка $L(S)$ любой системы векторов является подпространством в $V$. 
  Её также называют *подпространством, натянутым* на систему $S$.
])

#axiom_block("Минимальность", [
  Линейная оболочка $L(arrow(a)_1, ..., arrow(a)_k)$ есть наименьшее подпространство в $V$, содержащее векторы $arrow(a)_1, ..., arrow(a)_k$.
])

== Размерность оболочки
Размерность линейной оболочки равна *рангу* системы векторов $S$:
$ dim(L(S)) = op("rank")({arrow(a)_1, ..., arrow(a)_k}) $

#v(1em)

#pagebreak()
= Полные системы векторов

#note("Определение", [
  Система векторов $S = {arrow(a)_1, ..., arrow(a)_k}$ называется *полной* в пространстве $V$, если любой вектор $arrow(v) in V$ является их линейной комбинацией.
  $ L(arrow(a)_1, ..., arrow(a)_k) = V $
])

== Свойства полных систем

#axiom_block("Теорема о базисе", [
  Из любой конечной полной системы векторов можно выделить базис данного пространства. 
  *(Для этого нужно просто выкидывать линейно зависимые векторы, пока система не станет независимой).*
])

#axiom_block("Свойство избыточности", [
  Если к полной системе добавить любые векторы из $V$, она останется полной.
])

== Связь с размерностью
- Если система полная, то число векторов в ней $k >= dim V$.
- Если в полной системе ровно $n = dim V$ векторов, то она автоматически является базисом.

== Сравнение систем векторов

#table(
  columns: (1fr, 1.2fr, 1.2fr),
  inset: 10pt,
  align: horizon,
  fill: (x, y) => if y == 0 { blue.lighten(80%) },
  [*Параметр*], [*Полная система*], [*Базис*],
  
  [Геометрическая суть], 
  [Набор векторов, которых *достаточно*, чтобы заполнить всё пространство.], 
  [Минимально необходимый набор для заполнения пространства.],
  
  [Линейная зависимость], 
  [Может содержать "лишние" (зависимые) векторы.], 
  [Строго *линейно независима*. Нет ни одного лишнего вектора.],
  
  [Количество векторов], 
  [$k >= n$ (где $n = dim V$).], 
  [Строго $n = dim V$.],
  
  [Разложение вектора $arrow(v) = sum alpha_i arrow(a)_i$], 
  [*Не единственно*. Один и тот же вектор можно собрать разными способами.], 
  [*Единственно*. У каждого вектора есть уникальный "паспорт" — координаты.],
)

#v(1em)
#note("Закон экономии", [
  - Из любой *полной системы* можно выкинуть лишнее и получить *базис*.
  - К любому *базису* можно добавить любой вектор и получить *полную систему*.
])

#pagebreak()
= Линейно независимые и зависимые системы

#note("Базовое уравнение", [
  Рассмотрим равенство:
  $ alpha_1 arrow(v)_1 + alpha_2 arrow(v)_2 + ... + alpha_k arrow(v)_k = arrow(0) $
])

== 1. Определения
#grid(
  columns: (1fr, 1fr),
  gutter: 15pt,
  axiom_block("Линейная независимость", [
    Система независима, если уравнение выше имеет *только тривиальное* решение:
    $ alpha_1 = alpha_2 = ... = alpha_k = 0 $
  ]),
  axiom_block("Линейная зависимость", [
    Система зависима, если существует *хотя бы один* $alpha_i != 0$, при котором сумма равна $arrow(0)$.
  ])
)

== 2. Свойства линейно зависимых систем

#axiom_block("Свойство 1: О нулевом векторе", [
  Если в систему векторов входит нулевой вектор $arrow(0)$, то такая система *всегда* линейно зависима.
  _Доказательство_: Достаточно взять коэффициент при нулевом векторе $alpha != 0$, а остальные обнулить.
])

#axiom_block("Свойство 2: О подсистеме", [
  Если какая-либо часть (подсистема) системы векторов линейно зависима, то и *вся система* линейно зависима.
  _Суть_: Зависимость — это как "вирус", она делает всю компанию зависимой.
])

#axiom_block("Свойство 3: О линейной комбинации", [
  Система из двух и более векторов зависима тогда и только тогда, когда хотя бы один из векторов является *линейной комбинацией* остальных.
])

#axiom_block("Свойство 4: О независимой системе", [
  Любая подсистема линейно независимой системы сама является линейно независимой.
])

== 3. Критерий независимости в $RR^n$
Система векторов $arrow(v)_1, ..., arrow(v)_n$ в пространстве $RR^n$ линейно независима тогда и только тогда, когда определитель матрицы, составленной из этих векторов, *не равен нулю*:
$ det(A) != 0 $

#pagebreak()
= Лемма о замене (лемма Стейнца)

#note("Формулировка", [
  Пусть в линейном пространстве $V$ заданы две системы векторов:
  1. $L = {arrow(a)_1, ..., arrow(a)_n}$ — *полная* система.
  2. $K = {arrow(b)_1, ..., arrow(b)_m}$ — *линейно независимая* система.
  
  Тогда:
  - Число независимых векторов не превосходит числа полных: $m <= n$.
  - Можно заменить $m$ векторов системы $L$ векторами системы $K$ так, что полученная система останется полной.
])

== Главные следствия

#axiom_block("Теорема о размерности", [
  Во всяком конечномерном линейном пространстве все базисы состоят из *одинакового* числа векторов. Это число называется *размерностью* пространства ($dim V$).
])

#axiom_block("Признак зависимости", [
  В пространстве размерности $n$ любая система из $m > n$ векторов является *линейно зависимой*.
])

== Идея доказательства (индукция)
1. Берем $arrow(b)_1$. Т.к. $L$ полная, $arrow(b)_1$ выражается через $arrow(a)_i$. Т.к. $arrow(b)_1 != 0$, то есть коэффициент $alpha_i != 0$. Заменяем этот $arrow(a)_i$ на $arrow(b)_1$.
2. Система остается полной. Повторяем процесс для $arrow(b)_2, ..., arrow(b)_m$.
3. Если бы $m > n$, то после $n$ шагов все $arrow(a)$ закончились бы, и оставшиеся $arrow(b)$ выражались бы через предыдущие, что противоречит их независимости.

#pagebreak()
= Базис линейного пространства

#note("Определение", [
  Система векторов $e = {arrow(e)_1, ..., arrow(e)_n}$ называется *базисом* пространства $V$, если она одновременно линейно независима и является полной (порождающей) системой в $V$.
])

== 4 фундаментальные теоремы о базисе

#axiom_block("Теорема 1: О единственности координат", [
  Для любого вектора $arrow(x) in V$ существует единственный набор чисел $(x_1, ..., x_n)$, такой что:
  $ arrow(x) = sum_(i=1)^n x_i arrow(e)_i $
  Числа $x_i$ называются *координатами* вектора $arrow(x)$ в базисе $e$.
])

#axiom_block("Теорема 2: Об инвариантности размерности", [
  Все базисы конечномерного пространства состоят из одинакового количества векторов. Это число называется *размерностью* пространства ($dim V$).
])

#axiom_block("Теорема 3: О дополнении до базиса", [
  Любую линейно независимую систему векторов $S subset V$ можно дополнить до базиса пространства $V$.
])

#axiom_block("Теорема 4: Критерий базиса", [
  В пространстве размерности $n$ любая линейно независимая система из $n$ векторов является базисом.
])

#pagebreak()
= Доказательства теорем о базисе

== Теорема 1: О единственности координат
#axiom_block("Доказательство", [
  1. Пусть вектор $arrow(x)$ имеет два разложения в базисе $e$:
     $ arrow(x) = sum alpha_i arrow(e)_i quad "и" quad arrow(x) = sum beta_i arrow(e)_i $
  2. Вычтем одно из другого:
     $ arrow(0) = arrow(x) - arrow(x) = sum (alpha_i - beta_i) arrow(e)_i $
  3. Так как $arrow(e)_i$ — базис, они *линейно независимы*. Значит, такая комбинация равна нулю только при нулевых коэффициентах:
     $ alpha_i - beta_i = 0 => alpha_i = beta_i " для всех " i. $
  *Вывод*: Разложение единственно. _Q.E.D._
])

== Теорема 2: Об инвариантности размерности
#axiom_block("Доказательство", [
  Пусть в пространстве есть два базиса: $e$ из $n$ векторов и $f$ из $m$ векторов.
  1. Базис $e$ — полная система, $f$ — независимая. По *Лемме о замене*: $m <= n$.
  2. Поменяем их ролями. Базис $f$ — полная система, $e$ — независимая. По *Лемме о замене*: $n <= m$.
  3. Из $m <= n$ и $n <= m$ следует, что $n = m$.
  *Вывод*: Число векторов в любом базисе одинаково. _Q.E.D._
])

== Теорема 3: О дополнении до базиса
#axiom_block("Доказательство", [
  Пусть $S = {arrow(v)_1, ..., arrow(v)_k}$ — независимая система, а $dim V = n$ ($k < n$).
  1. Так как $k < n$, система $S$ не может быть полной (иначе бы $dim V$ была $<= k$).
  2. Значит, существует вектор $arrow(u) in V$, который не выражается через $S$.
  3. Добавим его: $S' = S union {arrow(u)}$. Новая система останется независимой.
  4. Повторяем процесс, пока число векторов не станет равным $n$.
  *Вывод*: Любую независимую систему можно достроить до "каркаса" (базиса). _Q.E.D._
])

== Теорема 4: Критерий базиса
#axiom_block("Доказательство", [
  Пусть $dim V = n$ и у нас есть $n$ независимых векторов. Докажем, что они образуют базис.
  1. По определению базиса нам не хватает только свойства *полноты*.
  2. Предположим от противного: система не полная. Тогда существует вектор $arrow(w)$, который через них не выражается.
  3. Добавив его, мы получим систему из $n + 1$ независимых векторов.
  4. Но по *Лемме о замене*, в пространстве размерности $n$ не может быть больше $n$ независимых векторов.
  *Противоречие*. Значит, система обязана быть полной. _Q.E.D._
])

== Координаты вектора
Разложение $arrow(x) = x_1 arrow(e)_1 + ... + x_n arrow(e)_n$ позволяет отождествить абстрактный вектор с вектором-столбцом из $RR^n$:
$ [arrow(x)]_e = mat(x_1; x_2; dots; x_n) $

#pagebreak()
= Билет: Изоморфизм линейных пространств

#let cong = sym.tilde.equiv

#note("Определение", [
  Линейные пространства $V$ и $W$ над полем $F$ называются *изоморфными* ($V cong W$), если существует отображение $f: V -> W$, такое что:
  1. $f$ — биекция (взаимно-однозначное соответствие).
  2. $f(alpha arrow(u) + beta arrow(v)) = alpha f(arrow(u)) + beta f(arrow(v))$ (линейность).
])

== Теорема об изоморфизме
#axiom_block("Утверждение", [
  Два конечномерных линейных пространства изоморфны тогда и только тогда, когда их размерности равны:
  $ V cong W <=> dim V = dim W $
])

#axiom_block("Идея доказательства", [
  - *$=>$*: Изоморфизм переводит базис пространства $V$ в базис пространства $W$. Т.к. биекция сохраняет количество элементов, то $dim V = dim W$.
  - *В обратную сторону*: Если $dim V = dim W = n$, выберем в $V$ базис $e$ и в $W$ базис $g$. Отображение, сопоставляющее вектору $arrow(v) = sum x_i arrow(e)_i$ вектор $arrow(w) = sum x_i arrow(g)_i$ (с теми же координатами), будет являться изоморфизмом.
])

#pagebreak()
= Базис и размерность подпространства

#note("Определение", [
  Система векторов ${arrow(e)_1, ..., arrow(e)_k}$ называется *базисом подпространства* $L subset V$, если:
  1. Все векторы $arrow(e)_i$ принадлежат $L$.
  2. Система линейно независима.
  3. Система является полной в $L$ (любой вектор из $L$ выражается через них).
])

== 1. Размерность подпространства
#axiom_block("Теорема", [
  Число векторов в любом базисе подпространства $L$ называется его *размерностью* и обозначается $dim L$.
])

== 2. Связь с объемлющим пространством
Пусть $V$ — конечномерное пространство, а $L$ — его подпространство. Тогда:

#axiom_block("Свойства размерности", [
  1. *Ограниченность*: размерность подпространства не может превышать размерность всего пространства: $dim L <= dim V$.
  2. *Критерий совпадения*: если $dim L = dim V$, то подпространство совпадает с самим пространством: $L = V$.
  3. *Дополнение*: любой базис подпространства $L$ можно дополнить до базиса всего пространства $V$.
])

== 3. Практический смысл (Ранг)
Если подпространство $L$ задано как линейная оболочка системы векторов $S = {arrow(a)_1, ..., arrow(a)_m}$, то его размерность равна *рангу* этой системы векторов:
$ dim L = op("rank")(S) $

#v(1em)

#pagebreak()
= Сумма и пересечение подпространств

#let inter = sym.inter // Пересечение ∩
#let dsum = math.xor // Прямая сумма ⊕

== 1. Определения
#axiom_block("Пересечение и Сумма", [
  - *Пересечением* $L_1 inter L_2$ называется множество векторов, принадлежащих одновременно $L_1$ и $L_2$.
  - *Суммой* $L_1 + L_2$ называется линейная оболочка объединения этих подпространств:
    $ L_1 + L_2 = { arrow(u) + arrow(v) | arrow(u) in L_1, arrow(v) in L_2 } $
])

== 2. Теорема Грассмана (Формула размерности)
#note("Важнейшая формула", [
  Сумма размерностей двух подпространств равна размерности их суммы плюс размерность их пересечения:
  $ bold(dim(L_1 + L_2) = dim L_1 + dim L_2 - dim(L_1 inter L_2)) $
])

== 3. Прямая сумма
#note("Определение", [
  Сумма подпространств называется *прямой* ($L_1 dsum L_2$), если их пересечение тривиально: $L_1 inter L_2 = {arrow(0)}$.
])

#axiom_block("Критерии прямой суммы", [
  Следующие утверждения эквивалентны:
  1. Сумма $L_1 + L_2$ является прямой.
  2. Любой вектор $arrow(x) in L_1 + L_2$ представляется в виде $arrow(x) = arrow(u) + arrow(v)$ единственным образом.
  3. $dim(L_1 + L_2) = dim L_1 + dim L_2$.
])

#v(4em)
== Расчет
- *Базис суммы*: выписать векторы базисов $L_1$ и $L_2$ в одну матрицу и найти её ранг (базисные строки).
- *Базис пересечения*: найти векторы, удовлетворяющие системам уравнений обоих подпространств одновременно (решить систему $A_1 x = 0$ и $A_2 x = 0$ вместе).

#pagebreak()
= Ранг матрицы. Элементарные преобразования

#note("Определение", [
  *Рангом матрицы* $A$ называется максимальное число её линейно независимых строк (или столбцов). 
  Обозначение: $op("rank")(A)$ или $r(A)$.
])

== 1. Определения через миноры
#axiom_block("Минорный ранг", [
  Ранг матрицы равен наибольшему из порядков её отличных от нуля миноров.
  - Если все миноры порядка $k+1$ равны нулю, а хотя бы один минор порядка $k$ не равен нулю, то $op("rank")(A) = k$.
])

== 2. Элементарные преобразования
#note("Свойство", [
  Элементарные преобразования переводят матрицу в *эквивалентную* ($A tilde B$), при этом ранг матрицы не изменяется.
])

#axiom_block("Список преобразований", [
  1. Перестановка двух строк или двух столбцов.
  2. Умножение строки (столбца) на ненулевой скаляр $lambda$.
  3. Прибавление к элементам одной строки (столбца) соответствующих элементов другой строки (столбца), умноженных на число.
  4. Отбрасывание нулевой строки (столбца).
])

== 3. Вычисление ранга
Самый эффективный способ найти ранг — привести матрицу к *ступенчатому виду* с помощью метода Гаусса.
#note("Теорема", [
  Ранг ступенчатой матрицы равен количеству её ненулевых строк.
])

#v(1em)

#pagebreak()
= Метод Гаусса и ступенчатые матрицы

#note("Ступенчатая матрица (REF)", [
  Матрица имеет *ступенчатый вид*, если первый ненулевой элемент каждой строки находится правее первого ненулевого элемента предыдущей строки.
])

== 1. Улучшенный ступенчатый вид (RREF)
#axiom_block("Определение", [
  Ступенчатая матрица называется *улучшенной (приведенной)*, если:
  1. Ведущие элементы всех строк равны 1.
  2. В столбце с ведущей единицей все остальные элементы равны 0.
])

== 2. Метод Гаусса (Алгоритм)
#table(
  columns: (1fr, 2fr),
  inset: 10pt,
  [*Ход*], [*Цель и действия*],
  [Прямой ход], [Приведение к ступенчатому виду. Исключение неизвестных сверху вниз. Позволяет найти *Ранг*.],
  [Обратный ход], [Приведение к улучшенному виду. Получение значений неизвестных снизу вверх.],
)

== 3. Теорема о ранге
#note("Теорема", [
  Любая матрица с помощью элементарных преобразований строк может быть приведена к ступенчатому виду. При этом количество ступенек (ненулевых строк) равно *рангу матрицы*.
])

== Примеры операций (нотация):
- $R_i arrow.r R_i + lambda R_j$ (прибавить к $i$-й строке $j$-ю, помноженную на $lambda$).
- $R_i <-> R_j$ (поменять строки местами).
- $R_i arrow.r R_i / k$ (нормировка строки).

#axiom_block("Доказательство (Теорема о ступенчатом виде)", [
  1. *База индукции*: Для матрицы из одной строки ($m=1$) она либо нулевая, либо уже ступенчатая.
  2. *Шаг индукции*: Пусть для матриц с $(m-1)$ строками утверждение верно. Рассмотрим матрицу $A$ размера $m times n$.
  3. Найдем первый слева столбец $j$, содержащий хотя бы один ненулевой элемент $a_(i j) != 0$.
  4. Переставим строки так, чтобы этот элемент оказался в первой строке ($a_(1 j) != 0$).
  5. Для всех строк $i > 1$ выполним преобразование: $R_i arrow.r R_i - (a_(i j) / a_(1 j)) R_1$. Теперь под элементом $a_(1 j)$ стоят только нули.
  6. Рассмотрим подматрицу, состоящую из строк со 2-й по $m$-ю. По предположению индукции её можно привести к ступенчатому виду.
  7. Т.к. первая строка и нули под $a_(1 j)$ не нарушают структуру "лесенки", вся матрица становится ступенчатой. *Q.E.D.*
])

#note("Утверждение", [
  Для любой матрицы $A$ число линейно независимых строк равно числу линейно независимых столбцов.
])

#axiom_block("Доказательство (схема)", [
  1. Приведем матрицу $A$ к ступенчатому виду $S$ с помощью элементарных преобразований строк.
  2. *По строкам*: Элементарные преобразования не меняют линейную оболочку строк (мы просто заменяем векторы на их комбинации). Следовательно, $op("rank")_("стр")(A) = op("rank")_("стр")(S)$.
  3. В ступенчатой матрице $S$ число ненулевых строк явно равно числу независимых строк (т.к. они образуют "лесенку"). Обозначим это число $r$.
  4. *По столбцам*: Элементарные преобразования строк сохраняют линейные зависимости между столбцами. 
     - Если $sum lambda_j arrow(c)_j = arrow(0)$, то после $R_i arrow.r R_i + k R_s$ равенство сохранится для каждой координаты.
     - Значит, $op("rank")_("ст")(A) = op("rank")_("ст")(S)$.
  5. В ступенчатой матрице $S$ ровно $r$ столбцов являются базисными (те, что содержат ступеньки). Остальные через них выражаются. Значит, $op("rank")_("ст")(S) = r$.
  6. Итого: $op("rank")_("стр")(A) = r$ и $op("rank")_("ст")(A) = r$. 
  *Следовательно*: $op("rank")_("стр")(A) = op("rank")_("ст")(A)$. _Q.E.D._
])

#import "@preview/cetz:0.3.2"

// --- Настройки и Алиасы (чтобы всё работало) ---
#let ar = math.arrow
#let rank = math.op("rank")
#let det = math.op("det")
#let tr = math.op("tr")
#let pr = math.op("пр") // Проекция
#let vol = math.op("V") // Объем

// Шаблоны оформления (из твоего стиля)
#let note(title, body) = rect(
  fill: blue.lighten(95%),
  stroke: blue.darken(20%) + 1pt,
  radius: 4pt,
  width: 100%,
  inset: 12pt
)[
  *#title* \
  #body
]

#let axiom_block(title, content) = block(
  width: 100%,
  stroke: 0.5pt + gray,
  radius: 3pt,
  inset: 12pt,
  fill: rgb("#fafafa")
)[
  #align(center)[#text(weight: "bold")[#title]]
  #v(0.4em)
  #content
]

#let ax(id, body) = grid(
  columns: (40pt, 1fr),
  gutter: 10pt,
  [*#id*],
  body
)

// --- НАЧАЛО КОНСПЕКТА ---

#pagebreak()
= Теория СЛАУ. Теорема Кронекера-Капелли

#note("Теорема Кронекера-Капелли", [
  Система линейных алгебраических уравнений $A x = b$ совместна (имеет хотя бы одно решение) тогда и только тогда, когда ранг матрицы системы равен рангу расширенной матрицы:
  $ rank(A) = rank(tilde(A)), space "где" tilde(A) = (A | b) $
])

#axiom_block("Доказательство", [
  1. *$=>$ (Необходимость)*: Пусть система имеет решение $x = (c_1, ..., c_n)$.
     Запишем систему в векторном виде: $c_1 ar(a)_1 + ... + c_n ar(a)_n = ar(b)$, где $ar(a)_i$ — столбцы матрицы $A$.
     Это значит, что столбец $ar(b)$ является линейной комбинацией столбцов $A$. Следовательно, добавление этого столбца в матрицу не увеличивает количество линейно независимых столбцов.
     $=> rank(tilde(A)) = rank(A)$.
  
  2. *$<=$ (Достаточность)*: Пусть $rank(A) = rank(tilde(A)) = r$.
     Пусть $ar(a)_(i_1), ..., ar(a)_(i_r)$ — базисные столбцы матрицы $A$. Так как ранг расширенной матрицы тоже $r$, эти же столбцы остаются базисными и для $tilde(A)$.
     Значит, последний столбец $ar(b)$ линейно выражается через базисные:
     $ ar(b) = lambda_1 ar(a)_(i_1) + ... + lambda_r ar(a)_(i_r) $
     Коэффициенты этого разложения (с нулями на местах небазисных столбцов) и есть решение системы. *Q.E.D.*
])

= Однородные системы линейных уравнений

#note("Определение", [
  Система $A x = 0$ называется *однородной*. Она всегда совместна, так как имеет тривиальное решение $x = ar(0)$.
])

#axiom_block("Свойства решений", [
  Множество решений однородной системы образует *линейное подпространство* в $RR^n$.
  _Доказательство_:
  Если $x_1$ и $x_2$ — решения ($A x_1 = 0, A x_2 = 0$), то:
  $ A(alpha x_1 + beta x_2) = alpha A x_1 + beta A x_2 = alpha dot 0 + beta dot 0 = 0 $
  Значит, любая линейная комбинация решений — тоже решение.
])

== Фундаментальная система решений (ФСР)
Базис пространства решений однородной системы называется ФСР.
Размерность этого пространства (количество векторов в ФСР):
$ k = n - rank(A) $
где $n$ — число неизвестных.

= Структура решения систем линейных уравнений

#note("Теорема о структуре общего решения", [
  Общее решение *неоднородной* системы ($A x = b$) равно сумме любого её частного решения ($x_"част"$) и общего решения соответствующей однородной системы ($x_"одн"$):
  $ x_"общ" = x_"част" + x_"одн" $
])

#axiom_block("Доказательство", [
  1. Пусть $x$ — произвольное решение $A x = b$.
  2. Пусть $x^*$ — фиксированное частное решение $A x^* = b$.
  3. Рассмотрим разность $x_0 = x - x^*$.
  4. Подставим в систему: $A x_0 = A(x - x^*) = A x - A x^* = b - b = 0$.
  5. Значит, $x_0$ — решение однородной системы. Отсюда $x = x^* + x_0$. *Q.E.D.*
])

#pagebreak()
= Полилинейные функции. Определитель

#note("Определение", [
  *Определитель* (детерминант) порядка $n$ — это функция $det: M_(n times n) -> F$, которая сопоставляет квадратной матрице число и обладает свойствами:
  1. *Полилинейность*: линейна по каждой строке.
  2. *Кососимметричность*: меняет знак при перестановке двух строк.
  3. *Нормировка*: $det(I) = 1$.
])

= Перестановки, инверсии, транспозиции

- *Перестановка* $sigma$ из $n$ элементов — это взаимно-однозначное отображение множества ${1, ..., n}$ на себя.
- *Инверсия* — пара индексов $(i, j)$, такая что $i < j$, но $sigma(i) > sigma(j)$ (нарушение порядка).
- *Четность*: $sgn(sigma) = (-1)^N$, где $N$ — количество инверсий.
- *Транспозиция* — перестановка, меняющая местами только два элемента. Транспозиция всегда меняет четность перестановки.

= Свойства определителя

#axiom_block("Ключевые свойства", [
  1. $det(A) = det(A^T)$ (равноправие строк и столбцов).
  2. При перестановке двух строк определитель меняет знак на противоположный.
  3. Определитель с двумя одинаковыми строками равен 0.
  4. Общий множитель строки можно выносить за знак определителя.
  5. Если к одной строке прибавить другую, умноженную на число, определитель *не изменится*.
  6. Определитель треугольной матрицы равен произведению элементов на диагонали.
])

= Определитель произведения матриц

#note("Теорема", [
  Определитель произведения квадратных матриц равен произведению их определителей:
  $ det(A B) = det(A) dot det(B) $
])

= Разложение определителя по строке

#note("Теорема Лапласа", [
  Определитель равен сумме произведений элементов любой строки (или столбца) на их алгебраические дополнения:
  $ det(A) = sum_(k=1)^n a_(i k) A_(i k) $
])
- *Минор* $M_(i j)$: определитель матрицы без $i$-й строки и $j$-го столбца.
- *Алгебраическое дополнение*: $A_(i j) = (-1)^(i+j) M_(i j)$.

#pagebreak()
= Обратная матрица, свойства

#note("Определение", [
  Матрица $A^(-1)$ называется *обратной* к квадратной матрице $A$, если:
  $ A A^(-1) = A^(-1) A = I $
])

#axiom_block("Свойства", [
  1. $(A^(-1))^(-1) = A$.
  2. $(A B)^(-1) = B^(-1) A^(-1)$ (порядок меняется!).
  3. $(A^T)^(-1) = (A^(-1))^T$.
  4. $det(A^(-1)) = 1 / det(A)$.
])

= Критерий обратимости, явная формула

#note("Критерий", [
  Матрица $A$ обратима тогда и только тогда, когда она *невырождена*, то есть $det(A) != 0$.
])

#axiom_block("Явная формула (через присоединенную матрицу)", [
  $ A^(-1) = 1 / det(A) dot C^T $
  где $C$ — матрица алгебраических дополнений ($C_(i j) = A_(i j)$).
])

= Метод Гаусса-Жордана вычисления обратной матрицы

Это практический способ нахождения $A^(-1)$ с помощью элементарных преобразований.
1. Записываем блочную матрицу $(A | I)$.
2. Приводим левую часть к единичной матрице $I$ с помощью преобразований строк.
3. Правая часть автоматически превратится в $A^(-1)$.
$ (A | I) tilde ... tilde (I | A^(-1)) $

= Теорема Крамера

#note("Теорема", [
  Если $det(A) != 0$, то система $A x = b$ имеет единственное решение, которое находится по формулам:
  $ x_i = det(A_i) / det(A) $
  где $A_i$ — матрица, полученная из $A$ заменой $i$-го столбца на столбец свободных членов $b$.
])

#axiom_block("Доказательство (через разложение по столбцу)", [
  Запишем $A x = b$ как $x_1 ar(a)_1 + ... + x_i ar(a)_i + ... + x_n ar(a)_n = ar(b)$.
  В матрице $A_i$ $i$-й столбец заменен на $ar(b)$. Разложим этот $ar(b)$ по формуле выше.
  По свойствам определителя (линейность по столбцу), $det(A_i) = x_1 det(...) + ... + x_i det(A) + ...$
  Все слагаемые, кроме $x_i det(A)$, занулятся (так как там будут два одинаковых столбца).
  Итого: $det(A_i) = x_i det(A) => x_i = det(A_i) / det(A)$. *Q.E.D.*
])

#pagebreak()
= Матрица перехода к новому базису, ее свойства

Пусть $e = {ar(e)_1, ..., ar(e)_n}$ — старый базис, $e' = {ar(e')_1, ..., ar(e')_n}$ — новый базис.

#note("Определение", [
  *Матрицей перехода* от базиса $e$ к базису $e'$ называется матрица $C$, столбцы которой составлены из координат новых базисных векторов в старом базисе:
  $ ar(e')_j = sum_(i=1)^n c_(i j) ar(e)_i $
  Матричная запись: $(ar(e')_1, ..., ar(e')_n) = (ar(e)_1, ..., ar(e)_n) dot C$.
])

*Свойства:*
1. Матрица перехода всегда невырождена: $det(C) != 0$.
2. Обратный переход: $C_(e' -> e) = (C_(e -> e'))^(-1)$.
3. Цепное правило: $C_(e -> e'') = C_(e -> e') dot C_(e' -> e'')$.

= Переход к новым координатам при смене базиса

Пусть вектор $ar(x)$ имеет столбец координат $X$ в базисе $e$ и столбец $X'$ в базисе $e'$.
Матрица перехода $C$ (от $e$ к $e'$).

#note("Формула преобразования координат", [
  $ X = C dot X' $
  *(Старые координаты = Матрица перехода $dot$ Новые координаты)*
])

#axiom_block("Внимание (важное отличие)", [
  - Векторы базиса преобразуются *прямо*: $e' = e C$.
  - Координаты векторов преобразуются *обратно*: $X' = C^(-1) X$.
])

#pagebreak()
= Векторная алгебра. Геометрические векторные пространства

== Закрепленный и свободный вектор
- *Закрепленный вектор*: направленный отрезок $ar(A B)$ с фиксированным началом $A$ и концом $B$.
- *Свободный вектор*: множество всех эквивалентных (равных по длине и направлению) закрепленных векторов. В линале мы работаем со свободными векторами (их можно переносить параллельно самим себе).

= Линейные операции, нормирование, проекция

1. *Линейные операции*: сложение (правило треугольника/параллелограмма) и умножение на число (растяжение).
2. *Нормирование*: деление вектора на его длину для получения *орта* (единичного вектора): $ar(e)_a = ar(a) / |ar(a)|$.
3. *Проекция на ось* $l$ (задаваемую вектором $ar(e)$):
   $ pr_l ar(a) = |ar(a)| cos phi $

= Линейная зависимость в геометрических пространствах

- 2 вектора зависимы $<=>$ они *коллинеарны* (лежат на одной прямой, $ar(a) || ar(b)$).
- 3 вектора зависимы $<=>$ они *компланарны* (лежат в одной плоскости).
- 4 вектора в 3D пространстве *всегда* линейно зависимы.

= Базисы и координаты. Направляющие косинусы

- *Стандартный ортонормированный базис*: $ar(i), ar(j), ar(k)$.
  - Попарно перпендикулярны.
  - Длина каждого равна 1.
- *Направляющие косинусы*:
  Координаты орта вектора — это косинусы углов вектора с осями:
  $ ar(e) = (cos alpha, cos beta, cos gamma), space "где" cos^2 alpha + cos^2 beta + cos^2 gamma = 1 $

#pagebreak()
= Скалярное произведение

#note("Определение", [
  $ (ar(a), ar(b)) = |ar(a)| dot |ar(b)| dot cos phi $
  В координатах (ортонормированный базис):
  $ (ar(a), ar(b)) = x_1 x_2 + y_1 y_2 + z_1 z_2 $
])

*Свойства:*
1. $ar(a) dot ar(b) = ar(b) dot ar(a)$.
2. Линейность: $(ar(a) + ar(b)) dot ar(c) = ar(a) dot ar(c) + ar(b) dot ar(c)$.
3. $ar(a) dot ar(a) = |ar(a)|^2 >= 0$.
4. Критерий перпендикулярности: $ar(a) perp ar(b) <=> (ar(a), ar(b)) = 0$.

= Векторное произведение

#note("Определение", [
  Векторным произведением $[ar(a), ar(b)]$ называется вектор $ar(c)$, такой что:
  1. $|ar(c)| = |ar(a)| dot |ar(b)| dot sin phi$ (численно равен площади параллелограмма).
  2. $ar(c) perp ar(a)$ и $ar(c) perp ar(b)$.
  3. Тройка $ar(a), ar(b), ar(c)$ — правая.
])

#align(center)[
  #cetz.canvas(length: 1cm, {
    import cetz.draw: *
    line((0,0), (2, -0.5), mark: (end: "stealth"), stroke: blue, name: "a")
    content("a", $ar(a)$, anchor: "north")
    
    line((0,0), (1, 1.5), mark: (end: "stealth"), stroke: blue, name: "b")
    content("b", $ar(b)$, anchor: "east")
    
    line((0,0), (0, 2.5), mark: (end: "stealth"), stroke: (paint: red, thickness: 2pt), name: "c")
    content("c", $[ar(a), ar(b)]$, anchor: "south")
    
    // Площадь
    line((2, -0.5), (3, 1), (1, 1.5), stroke: (dash: "dashed"))
  })
]

*Формула в координатах*:
$ [ar(a), ar(b)] = det(mat(ar(i), ar(j), ar(k); x_1, y_1, z_1; x_2, y_2, z_2)) $

= Смешанное произведение

#note("Определение", [
  $(ar(a), ar(b), ar(c)) = ([ar(a), ar(b)], ar(c))$
])

*Геометрический смысл*: Объем ориентированного параллелепипеда, построенного на трех векторах.
*Критерий компланарности*: Векторы лежат в одной плоскости $<=> (ar(a), ar(b), ar(c)) = 0$.

#pagebreak()
= Декартова система координат. Общее уравнение плоскости

#note("Общее уравнение", [
  $ A x + B y + C z + D = 0 $
  Вектор $ar(n) = (A, B, C)$ является *нормальным вектором* (перпендикуляром) к плоскости.
])

= Уравнение плоскости по трем точкам. Расстояние

*Уравнение через 3 точки* $M_1, M_2, M_3$:
Векторы $ar(M_1 M)$, $ar(M_1 M_2)$, $ar(M_1 M_3)$ должны быть компланарны.
$ det(mat(x-x_1, y-y_1, z-z_1; x_2-x_1, y_2-y_1, z_2-z_1; x_3-x_1, y_3-y_1, z_3-z_1)) = 0 $

*Расстояние от точки $M_0$ до плоскости*:
$ d = |A x_0 + B y_0 + C z_0 + D| / sqrt(A^2 + B^2 + C^2) $

= Уравнения прямой в пространстве

#grid(
  columns: (1fr, 1fr),
  gutter: 10pt,
  axiom_block("Каноническое", [
    $ (x - x_0)/m = (y - y_0)/p = (z - z_0)/l $
    $ar(s) = (m, p, l)$ — направляющий вектор.
  ]),
  axiom_block("Параметрическое", [
    $ cases(x = x_0 + m t, y = y_0 + p t, z = z_0 + l t) $
  ])
)

*Расстояние от точки $M_1$ до прямой* (с направляющим $ar(s)$ и точкой $M_0$):
$ d = (|[ar(M_0 M_1), ar(s)]|) / (|ar(s)|) $ (Площадь параллелограмма / Основание)

= Взаимное расположение прямых и плоскостей

1. *Угол между плоскостями*: угол между их нормалями ($cos phi$).
2. *Угол между прямыми*: угол между их направляющими ($cos phi$).
3. *Угол между прямой и плоскостью*: угол между направляющим $ar(s)$ и нормалью $ar(n)$ дополняет искомый до 90°.
   $ sin phi = (|(ar(s), ar(n))|) / (|ar(s)| dot |ar(n)|) $

#pagebreak()
= Вывод уравнений кривых второго порядка. Свойства

#table(
  columns: (1fr, 2fr),
  inset: 10pt,
  [*Кривая*], [*Определение и уравнение*],
  [Эллипс], [Множество точек, сумма расстояний от которых до двух фокусов постоянна ($r_1 + r_2 = 2a$). \ Уравнение: $x^2/a^2 + y^2/b^2 = 1$. \ Свойства: $a^2 = b^2 + c^2$, эксцентриситет $epsilon = c/a < 1$.],
  [Гипербола], [Модуль разности расстояний до фокусов постоянен ($|r_1 - r_2| = 2a$). \ Уравнение: $x^2/a^2 - y^2/b^2 = 1$. \ Свойства: $c^2 = a^2 + b^2$, $epsilon = c/a > 1$, асимптоты $y = plus.minus b/a x$.],
  [Парабола], [Равноудалена от фокуса и директрисы. \ Уравнение: $y^2 = 2 p x$. \ Свойства: $epsilon = 1$.]
)

#align(center)[
  #cetz.canvas(length: 1cm, {
    import cetz.draw: *
    // Эллипс
    circle((0,0), radius: (2, 1), stroke: blue, name: "el")
    line((-1.5, 0), (0, 0.86), stroke: (dash: "dashed"))
    line((1.5, 0), (0, 0.86), stroke: (dash: "dashed"))
    content((0, -1.5), "Эллипс: сумма пунктиров = const")
    
    // Гипербола (схематично)
    content((5, -1.5), "Гипербола")
    line((4, -1), (4.5, 0), (4, 1), stroke: red) // левая ветвь
    line((6, -1), (5.5, 0), (6, 1), stroke: red) // правая ветвь
  })
]